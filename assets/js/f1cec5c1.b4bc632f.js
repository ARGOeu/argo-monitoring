"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3488],{9596:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var r=t(4848),i=t(8453);const s={sidebar_position:6,title:"Recomputations"},o="Introduction to Recomputation Requests",a={id:"profiles/recomputations",title:"Recomputations",description:"Recomputations are a vital mechanism for correcting or re-evaluating the status and availability/reliability (a/r) results of the Monitoring Service. They ensure that Monitoring Service's reports reflect accurate conditions, particularly when data is affected by unexpected events or planned interventions. These corrections uphold the principles of fairness, transparency, and accuracy in infrastructure monitoring.",source:"@site/docs/profiles/recomputations.md",sourceDirName:"profiles",slug:"/profiles/recomputations",permalink:"/argo-monitoring/docs/profiles/recomputations",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"Recomputations"},sidebar:"tutorialSidebar",previous:{title:"Metrics Tags",permalink:"/argo-monitoring/docs/profiles/metrics-tags"},next:{title:"Reports",permalink:"/argo-monitoring/docs/category/reports"}},c={},l=[{value:"Why Are Recomputation Requests Needed?",id:"why-are-recomputation-requests-needed",level:2},{value:"1. Exclude Monitoring Sources",id:"1-exclude-monitoring-sources",level:2},{value:"2. Exclude Groups",id:"2-exclude-groups",level:2},{value:"3. Exclude Metrics",id:"3-exclude-metrics",level:2},{value:"4. On-Demand Status Changes of Topology Items",id:"4-on-demand-status-changes-of-topology-items",level:2},{value:"Scope Hierarchy (From Most Granular to Least Granular)",id:"scope-hierarchy-from-most-granular-to-least-granular",level:2},{value:"<strong>Level 1 \u2013 Single Element Defined (Most General)</strong>",id:"level-1--single-element-defined-most-general",level:3},{value:"<strong>Level 2 \u2013 Two Elements Defined</strong>",id:"level-2--two-elements-defined",level:3},{value:"<strong>Level 3 \u2013 Three Elements Defined</strong>",id:"level-3--three-elements-defined",level:3},{value:"<strong>Level 4 \u2013 Four Elements Defined (Most Specific)</strong>",id:"level-4--four-elements-defined-most-specific",level:3},{value:"Evaluation and Ordering Logic",id:"evaluation-and-ordering-logic",level:2}];function d(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"introduction-to-recomputation-requests",children:"Introduction to Recomputation Requests"}),"\n",(0,r.jsx)(n.p,{children:"Recomputations are a vital mechanism for correcting or re-evaluating the status and availability/reliability (a/r) results of the Monitoring Service. They ensure that Monitoring Service's reports reflect accurate conditions, particularly when data is affected by unexpected events or planned interventions. These corrections uphold the principles of fairness, transparency, and accuracy in infrastructure monitoring."}),"\n",(0,r.jsx)(n.h2,{id:"why-are-recomputation-requests-needed",children:"Why Are Recomputation Requests Needed?"}),"\n",(0,r.jsx)(n.p,{children:"Recomputation requests are typically initiated when:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unexpected events"})," such as power outages, hardware failures, or network issues negatively impact the accuracy of monitoring data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Maintenance activities or scheduled downtimes"})," result in time periods that should not be included in availability or reliability calculations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Metric misconfigurations or data corruption"})," produce misleading or incorrect service states that need to be ignored or corrected."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Audits, post-mortems, or appeals"})," uncover historical inconsistencies that require manual adjustments for fair reporting."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"By defining a time range and the affected elements of the monitoring topology (e.g.,  metrics, endpoints,services,groups), users can request recomputations to adjust the resulting status timelines and availability figures to better reflect reality."}),"\n",(0,r.jsx)(n.h1,{id:"types-of-recomputation-requests-in-the-monitoring-service",children:"Types of Recomputation Requests in the Monitoring Service"}),"\n",(0,r.jsx)(n.p,{children:"Recomputation requests vary depending on the kind of correction needed. Each type targets a different aspect of the monitoring topology or behavior, ensuring that only the affected components or timeframes are adjusted."}),"\n",(0,r.jsx)(n.h2,{id:"1-exclude-monitoring-sources",children:"1. Exclude Monitoring Sources"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),":",(0,r.jsx)(n.br,{}),"\n","Exclude data originating from a faulty or unreliable monitoring source (e.g., a specific monitoring node or probe) during a defined time window."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),":",(0,r.jsx)(n.br,{}),"\n","In high-availability setups with multiple monitoring sources, one source might temporarily malfunction or produce erroneous results due to network issues, hardware failure, or misconfiguration. By excluding it, users can ensure that bad data does not contaminate service availability calculations."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Mechanism"}),":",(0,r.jsx)(n.br,{}),"\n","You provide the hostname of the monitoring node along with a time range. Data collected by this node during the period is excluded from all aggregation and availability/reliability (a/r) calculations."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Field"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'"exclude_monitoring_source": [\n  {\n    "host": "monitoring_node01.example.foo",\n    "start_time": "2022-01-10T12:00:00Z",\n    "end_time": "2022-01-10T23:00:00Z"\n  }\n]\n'})}),"\n",(0,r.jsx)(n.h2,{id:"2-exclude-groups",children:"2. Exclude Groups"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),":",(0,r.jsx)(n.br,{}),"\n","Prevent specific groups (e.g., site, project, or organizational groups) from influencing availability/reliability (a/r) results during a particular recomputation window."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),":",(0,r.jsx)(n.br,{}),"\n","Useful when a whole group of services or endpoints is known to be undergoing maintenance, or when a group\u2019s monitoring data is consistently unreliable for a period. This ensures group-level metrics do not distort higher-level calculations."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Mechanism"}),":",(0,r.jsx)(n.br,{}),"\n","Listed groups are ignored in the calculation of a/r results, although their internal timeline remains unchanged (i.e., statuses are recorded but not considered in report aggregation)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Field"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'"exclude": [ "Group-1", "Group-2" ]\n'})}),"\n",(0,r.jsx)(n.h2,{id:"3-exclude-metrics",children:"3. Exclude Metrics"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),":",(0,r.jsx)(n.br,{}),"\n","Temporarily ignore one or more specific metrics\u2014optionally scoped to a host, service, or group\u2014during recomputation."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),":",(0,r.jsx)(n.br,{}),"\n","When a particular check (metric) is misbehaving (e.g., wrongly configured thresholds, false alerts), it can negatively affect the status of its corresponding endpoint or service. Excluding such metrics avoids cascading misinterpretation of service health."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Mechanism"}),":",(0,r.jsx)(n.br,{}),"\n","Each excluded metric is specified, and optionally constrained to certain topological scopes (hostname, service, group). The metric\u2019s results are skipped in both timeline processing and a/r calculations."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Field"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'"exclude_metrics": [\n  { "metric": "check-1" },\n  { "metric": "check-2", "hostname": "host1.example.com" },\n  { "metric": "check-3", "group": "Affected-Site" }\n]\n'})}),"\n",(0,r.jsx)(n.h2,{id:"4-on-demand-status-changes-of-topology-items",children:"4. On-Demand Status Changes of Topology Items"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),":",(0,r.jsx)(n.br,{}),"\n","Manually override the computed status of any monitored component (group, service, endpoint, or metric) for a given time range."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),":",(0,r.jsx)(n.br,{}),"\n","Ideal for retrospective adjustments after validation, incident response, or audit. For example, if a downtime was mistakenly reported during a test, users can explicitly mark the component as \u201cOK\u201d or \u201cEXCLUDED\u201d to correct the historical record."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Mechanism"}),":",(0,r.jsx)(n.br,{}),"\n","A set of status overrides is declared, targeting specific topology items and assigning them a forced state (e.g., OK, CRITICAL, EXCLUDED). The system applies these during recomputation in place of the calculated results."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Field"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'  "applied_status_changes": [\n    {\n      "group": "Group-A",\n      "state": "CRITICAL"\n    },\n    {\n      "group": "Group-B",\n      "state": "CRITICAL"\n    },\n    {\n      "service": "Service-a",\n      "state": "OK"\n    },\n    {\n      "service": "Service-b",\n      "state": "OK"\n    },\n    {\n      "service": "Service-c",\n      "state": "CRITICAL"\n    },\n    {\n      "service": "Service-d",\n      "group": "Group-A",\n      "state": "CRITICAL"\n    },\n    {\n      "hostname": "Endpoint-a",\n      "state": "OK"\n    },\n    {\n      "hostname": "Endpoint-b",\n      "state": "OK"\n    },\n    {\n      "hostname": "Endpoint-c",\n      "state": "CRITICAL"\n    },\n    {\n      "hostname": "Endpoint-d",\n      "service": "Service-d",\n      "group": "Group-A",\n      "state": "OK"\n    },\n    {\n      "hostname": "Endpoint-e",\n      "service": "Service-d",\n      "state": "OK"\n    },\n    {\n      "hostname": "Endpoint-f",\n      "group": "Group-A",\n      "state": "OK"\n    },\n    {\n      "metric": "Metric-a",\n      "state": "EXCLUDED"\n    },\n    {\n      "metric": "Metric-a",\n      "service": "Service-a",\n      "state": "OK"\n    },\n    {\n      "metric": "Metric-a",\n      "hostname": "Endpoint-a",\n      "state": "OK"\n    },\n    {\n      "metric": "Metric-b",\n      "hostname": "Endpoint-b",\n      "service": "Service-b",\n      "state": "OK"\n    },\n    {\n      "metric": "Metric-c",\n      "hostname": "Endpoint-c",\n      "service": "Service-c",\n      "group": "Group-A",\n      "state": "OK"\n    },\n    {\n      "metric": "Metric-d",\n      "service": "Service-d",\n      "group": "Group-A",\n      "state": "OK"\n    },\n    {\n      "metric": "Metric-e",\n      "hostname": "Hostname-e",\n      "group": "Group-A",\n      "state": "OK"\n    }\n  ]\n'})}),"\n",(0,r.jsx)(n.h2,{id:"scope-hierarchy-from-most-granular-to-least-granular",children:"Scope Hierarchy (From Most Granular to Least Granular)"}),"\n",(0,r.jsxs)(n.p,{children:["This hierarchy defines how specifically recomputation rules target elements in the monitoring topology. Each level corresponds to a combination of one or more topology elements (",(0,r.jsx)(n.code,{children:"metric"}),", ",(0,r.jsx)(n.code,{children:"endpoint"}),", ",(0,r.jsx)(n.code,{children:"service"}),", ",(0,r.jsx)(n.code,{children:"group"}),")."]}),"\n",(0,r.jsx)(n.p,{children:"Although users can define the elements in any order, the system always evaluates recomputation rules by increasing scope\u2014from the most specific (with more elements) to the most general (with fewer elements). The more elements defined, the narrower and more targeted the rule's scope."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"level-1--single-element-defined-most-general",children:(0,r.jsx)(n.strong,{children:"Level 1 \u2013 Single Element Defined (Most General)"})}),"\n",(0,r.jsxs)(n.p,{children:["A rule defines only ",(0,r.jsx)(n.strong,{children:"one"})," topology element."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{ "metric": "Metric-a", "state": "CRITICAL" }\n{ "service": "Service-a", "state": "CRITICAL" }\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"level-2--two-elements-defined",children:(0,r.jsx)(n.strong,{children:"Level 2 \u2013 Two Elements Defined"})}),"\n",(0,r.jsx)(n.p,{children:"The rule specifies two topology elements."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{ "metric": "Metric-a", "endpoint": "Hostname-a", "state": "WARNING" }\n{ "metric": "Metric-a", "group": "Group-a", "state": "CRITICAL" }\n{ "endpoint": "Hostname-a", "group": "Group-a", "state": "WARNING" }\n{ "endpoint": "Hostname-a", "service": "Service-a", "state": "CRITICAL" }\n'})}),"\n",(0,r.jsx)(n.h3,{id:"level-3--three-elements-defined",children:(0,r.jsx)(n.strong,{children:"Level 3 \u2013 Three Elements Defined"})}),"\n",(0,r.jsx)(n.p,{children:"The rule includes three topology elements."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{ "metric": "Metric-a", "endpoint": "Hostname-a", "service": "Service-a", "state": "WARNING" }\n{ "metric": "Metric-a", "service": "Service-a", "group": "Group-a", "state": "WARNING" }\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"level-4--four-elements-defined-most-specific",children:(0,r.jsx)(n.strong,{children:"Level 4 \u2013 Four Elements Defined (Most Specific)"})}),"\n",(0,r.jsx)(n.p,{children:"The rule contains all four topology elements."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "metric": "Metric-a",\n  "endpoint": "Hostname-a",\n  "service": "Service-a",\n  "group": "Group-a",\n  "state": "WARNING"\n}\n\n'})}),"\n",(0,r.jsx)(n.h2,{id:"evaluation-and-ordering-logic",children:"Evaluation and Ordering Logic"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Within the same scope level"}),", if multiple recomputation rules refer to the ",(0,r.jsx)(n.strong,{children:"same topology element(s)"}),", all are evaluated in the order provided."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Across different levels"}),", recomputations are evaluated ",(0,r.jsx)(n.strong,{children:"in order of increasing specificity"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Level 1"})," \u2013 Least specific"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Level 2"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Level 3"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Level 4"})," \u2013 Most specific"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This ordering ensures that the system considers broader impact first and then applies more detailed recomputations as necessary."})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(6540);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);